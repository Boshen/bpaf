# bpaf ![License: MIT OR Apache-2.0](https://img.shields.io/badge/license-MIT%20OR%20Apache--2.0-blue) [![bpaf on crates.io](https://img.shields.io/crates/v/bpaf)](https://crates.io/crates/bpaf) [![bpaf on docs.rs](https://docs.rs/bpaf/badge.svg)](https://docs.rs/bpaf) [![Source Code Repository](https://img.shields.io/badge/Code-On%20github.com-blue)](https://github.com/pacak/bpaf) [![bpaf on deps.rs](https://deps.rs/repo/github/pacak/bpaf/status.svg)](https://deps.rs/repo/github/pacak/bpaf)

Lightweight and flexible command line argument parser with derive and combinator style API


## Quick start, derive edition

 1. Add `bpaf` under `[dependencies]` in your `Cargo.toml`


```toml
[dependencies]
bpaf = { version = "0.5", features = ["derive"] }
```

 2. Define a structure containing command line attributes


```rust
use bpaf::{Bpaf, OptionParser};

#[derive(Clone, Debug, Bpaf)]
#[bpaf(options, version)]
/// Accept speed and distance, print them
struct SpeedAndDistance {
    /// Speed in KPH
    speed: f64,
    /// Distance in miles
    distance: f64,
}

fn main() {
    // function options is generated by #[derive(Bpaf)] macro
    let opts = speed_and_distance().run();
    println!("Options: {:?}", opts);
}
```

 3. Try to run it


```console
% very_basic --help
Accept speed and distance, print them

Usage: --speed ARG --distance ARG

Available options:
        --speed <ARG>     Speed in KPH
        --distance <ARG>  Distance in miles
    -h, --help            Prints help information
    -V, --version         Prints version information

% very_basic --speed 100
Expected --distance ARG, pass --help for usage information

% very_basic --speed 100 --distance 500
Options: SpeedAndDistance { speed: 100.0, distance: 500.0 }

% very_basic --version
Version: 0.4.11 (taken from Cargo.toml by default)
```


## Quick start, combinatoric edition

 1. Add `bpaf` under `[dependencies]` in your `Cargo.toml`


```toml
[dependencies]
bpaf = "0.5"
```

 2. Declare parsers for components, combine them and run


```rust
use bpaf::{construct, long, Info, OptionParser, Parser};
#[derive(Clone, Debug)]
struct SpeedAndDistance {
    /// Dpeed in KPH
    speed: f64,
    /// Distance in miles
    distance: f64,
}

fn main() {
    let speed = long("speed")
        .help("Speed in KPG")
        .argument("SPEED")
        .from_str::<f64>();

    let distance = long("distance")
        .help("Distance in miles")
        .argument("DIST")
        .from_str::<f64>();

    let parser = construct!(SpeedAndDistance { speed, distance });
    let speed_and_distance
        = Info::default()
        .descr("Accept speed and distance, print them")
        .for_parser(parser);

    let opts = speed_and_distance.run();
    println!("Options: {:?}", opts);
}
```

 3. Try to run it, output should be similar to derive edition


## Getting started

Documentation is shared for combinatoric and derive APIs, recommended reading order:

 1. [`construct!`][__link0] - what combinations are and how you should read the examples
 1. [`Named`][__link1], [`positional`][__link2] and [`command`][__link3] - on consuming data
 1. [`Parser`][__link4] - on transforming the data
 1. [`OptionParser`][__link5] - on running the result
 1. *Using the library in derive style* section below


## Design goals: flexibility, reusability

Library allows to express command line arguments by combining primitive parsers using mostly regular Rust code plus one macro. For example it is possible to take a parser that requires a single floating point number and transform it to a parser that takes several of them or takes it optionally so different subcommands or binaries can share a lot of the code:


```rust
use bpaf::*;

// a regular function that doesn't depend on anything, can be exported and
// shared across subcommands and binaries
fn speed() -> impl Parser<f64> {
    long("speed")
        .help("Speed in KPH")
        .argument("SPEED")
        .from_str::<f64>()
}

// this parser accepts multiple `--speed` flags from a command line when used,
// collecting them into a vector
let multiple_args = speed().many(); // impl Parser<Vec<f64>>

// this parser checks if `--speed` is present and uses value of 42 if it is not
let with_fallback = speed().fallback(42.0); // impl Parser<Option<f64>>
```

At any point you can apply additional validation or fallback values in terms of current parsed state of each subparser and you can have several stages as well:


```rust
use bpaf::*;

#[derive(Clone, Debug)]
struct Speed(f64);

long("speed")
    .help("Speed in KPH")
    .argument("SPEED")
    // After this point we have a parser of type `impl Parser<String>`
    .from_str::<f64>()
    // `from_str` uses FromStr trait to transform contained value into `f64`

    // extra validation can be performed with `parse` or `guard` functions,
    // you can have as many steps as required. Before and after those steps
    // we still have parser of type `impl Parser<f64>`
    .guard(|&speed| speed >= 0.0, "You need to buy a DLC to move backwards")
    .guard(|&speed| speed <= 100.0, "You need to buy a DLC to break the speed limits")

    // contained values can be transformed, this gives `impl Parser<Speed>` as a result
    .map(|speed| Speed(speed));
```


## Design goals: restrictions

The main restriction library sets is that parsed values (but not the fact that parser succeeded or failed) can’t be used to decide how to parse subsequent values. In other words parsers don’t have the monadic strength, only the applicative one.

To give an example, following description is allowed:


> Program takes one of `--stdout` or `--file` flag to specify the output target, when it is `--file` program also requires `-f` attribute with the file name
> 
> 
But this one is not allowed:


> Program takes an `-o` attribute with possible values of `'stdout'` and `'file'`, when it’s `'file'` program also requires `-f` attribute with the file name
> 
> 
This set of restrictions allows to extract information about the structure of the computations to generate help and overall results in less confusing enduser experience


## Design non goals: performance

Library aims to optimize for flexibility, reusability and compilation time over runtime performance which means it might perform some additional clones, allocations and other less optimal things. In practice unless you are parsing tens of thousands of different parameters and your application exits within microseconds - this won’t affect you. That said - I will to look into any actual performance related problems with real world applications.


## Derive and combinatoric API

Library supports both derive and combinatoric APIs whith combinatoric API being primary, it is possible to mix and match both APIs at once. Both APIs provide access to mostly the same functionality, some things are more convenient to do with derive (usually less typing), some - with combinatoric (usually maximum flexibility and reducing boilerplate structs). In most cases using just one would suffice. Whenever possible APIs share the same keywords and structure. Documentation for combinatoric API also explains how to perform the same action in derive style so you should read it.


## Using the library in combinatoric style

 1. Define primitive field parsers using builder pattern starting with [`short`][__link6], [`long`][__link7], [`command`][__link8] or [`positional`][__link9], add more information using [`help`][__link10], [`env`][__link11] and other member functions.
	
	For some constructors you end up with parser objects right away, some require finalization with [`argument`][__link12], [`flag`][__link13] or [`switch`][__link14].
	
	At the end of this step you’ll get one or more parser one or more objects implementing trait [`Parser`][__link15], such as `impl Parser<String>`.
	
	
 1. If you need additional parsing and validation you can use trait [`Parser`][__link16]: [`map`][__link17], [`parse`][__link18], [`guard`][__link19], [`from_str`][__link20].
	
	You can change type or shape of contained or shape with [`many`][__link21], [`some`][__link22], [`optional`][__link23] and add a fallback values with [`fallback`][__link24], [`fallback_with`][__link25].
	
	
 1. You can compose resulting primitive parsers using [`construct`][__link26] macro into a concrete datatype and still apply additional processing from step 2 after this.
	
	
 1. You define whole program metadata with [`Info`][__link27] and apply it to the toplevel parser created at the previous step using [`for_parser`][__link28].
	
	
 1. [`run`][__link29] the resulting parser at the beginning of your program. If parser succeeds you’ll get the results. If there are errors or user asked for help info `bpaf` will handle them and exit.
	
	


## Using the library in derive style

 1. To use derive style API you need to enable `"derive"` feature for bpaf, **by default it’s not enabled**.
	
	
 1. Define primitive parsers if you want to use any. While it is possible to define most of them in derive style - doing complex parsing or validation is often easier in combinatoric style
	
	
 1. Define types used to derive parsers, structs correspond to *AND* combination - all the values will be required, enums to *OR* combinations - only one branch will be accepted.
	
	
 1. Add annotations to the top level of a struct if needed, there’s several to choose from and you can specify several of them. For this annotation ordering does not matter.
	
	 - Generated function name. Unlike usual derive macro bpaf generates a function with a name derived from a struct name by transforming it from `CamelCase` to `snake_case`. `generate` allows to override a name for the function
	
	
	```rust
	use bpaf::*;
	
	#[derive(Debug, Clone, Bpaf)]
	#[bpaf(generate(make_config))] // function name is now make_config()
	pub struct Config {
	    pub flag: bool
	}
	```
	
	 - Generated function visibility. By default bpaf uses the same visibility as the datatype, `private` makes it module private:
	
	
	```rust
	use bpaf::*;
	
	#[derive(Debug, Clone, Bpaf)]
	#[bpaf(private)] // config() is now private
	pub struct Config {
	    pub flag: bool
	}
	```
	
	 - Generated function type. By default bpaf would generate a function that parses all the fields present (`impl` [`Parser`][__link30]), it is possible instead to turn it into a one or more [`command`][__link31] with or top level `impl` [`OptionParser`][__link32] with `options`. Those annotations are mutually exclusive. `options` annotation takes an optional argument to wrap options into [`cargo_helper`][__link33], `command` annotation takes an optional argument to override a command name.
	
	
	```rust
	use bpaf::*;
	
	#[derive(Debug, Clone, Bpaf)]
	pub struct Flag { // impl Parser by default
	    pub flag: bool
	}
	
	#[derive(Debug, Clone, Bpaf)]
	#[bpaf(command)]
	pub struct Make { // generates a command "make"
	    pub level: u32,
	}
	
	
	#[derive(Debug, Clone, Bpaf)]
	#[bpaf(options)] // config() is now private
	pub struct Config {
	    pub flag: bool
	}
	```
	
	 - Specify version for generated command. By default bpaf would use version as defined by `"CARGO_PKG_VERSION"` env variable during compilation, usually taken from `Cargo.toml`, it is possible to override it with a custom expression. Only makes sense for `command` and `options` annotations. For more information see [`version`][__link34].
	
	
	```rust
	use bpaf::*;
	
	#[derive(Debug, Clone, Bpaf)]
	#[bpaf(options, version("3.1415"))] // --version is now 3.1415
	pub struct Config {
	    pub flag: bool
	}
	```
	
	
 - Add annotations to individual fields. Structure for annotation for individual fields is similar to how you would write the same code with combinatoric API with exception of `external` and usually looks something like this:
	
	`((<naming> <consumer>) | <external>) <postprocessing>`
	
	 - `naming` section corresponds to [`short`][__link35],  [`long`][__link36] and [`env`][__link37]. `short` takes an optional character literal as a parameter, `long` takes an optional string.
		
		 - If parameter for `short`/`long` is parameter is not present it is derived from the field name: first character and a whole name respectively.
			
			
		 - If either of `short` or `long` is present - bpaf would not add the other one.
			
			
		 - If neither is present - bpaf would add a long one.
			
			
		 - `env` takes an arbitrary expression of type `&'static str` - could be a string literal or a constant.
			
			
		
		
		```rust
		const DB: &str = "top_secret_database";
		
		#[derive(Debug, Clone, Bpaf)]
		pub struct Config {
		   pub flag_1: bool,     // no annotation: --flag_1
		
		   #[bpaf(short)]
		   pub flag_2: bool,     // explicit short suppresses long: -f
		
		   #[bpaf(short('z'))]
		   pub flag_3: bool,     // explicit short with custom letter: -z
		
		   #[bpaf(short, long)]
		   pub deposit: bool,    // explicit short and long: -d --deposit
		
		   #[bpaf(env(DB))]
		   pub database: String, // --database + env variable from DB constant
		
		   #[bpaf(env("USER"))]  // --user + env variable "USER"
		   pub user: String,
		}
		```
		
		
	 - `consumer` section corresponds to [`argument`][__link38], [`positional`][__link39], [`flag`][__link40], [`switch`][__link41] and similar.
		
		 - With no consumer annotations tuple structs (`struct Config(String)`) are usually parsed as positional items, but it is possible to override it by giving it a name:
		
		
		```rust
		
		#[derive(Debug, Clone, Bpaf)]
		struct Opt(PathBuf); // stays positional
		
		#[derive(Debug, Clone, Bpaf)]
		struct Config(#[bpaf(long("input"))] PathBuf); // turns into a named argument
		```
		
		 - Fields of type `Option<Foo>` and `Vec<Foo>` are turned into something that consumes possibly one or many items with [`optional`][__link42] and [`many`][__link43] respectively, see `postprocessing` for more details.
			
			
		 - `bool` fields are turned into [`switch`][__link44], [`OsString`][__link45] and [`PathBuf`][__link46] are consumed as either [`positional_os`][__link47] or [`argument_os`][__link48]. Everything else is consumed as [`String`][__link49] with [`positional`][__link50] and [`argument`][__link51]. See documentation for corresponding consumers for more details.
			
			
		
		
	 - `external` section usually replaces `naming`, `consumer` and optionally `postprocessing` sections. Takes an optional parameter - a function name to call, if not present - it will use field name for this purpose. Functions should return impl [`Parser`][__link52] and you can either declare them manually or derive with `Bpaf` macro.
		
		
		```rust
		use bpaf::*;
		
		fn verbosity() -> impl Parser<usize> {
		    short('v')
		        .help("vebosity, can specify multiple times")
		        .req_flag(())
		        .many()
		        .map(|x| x.len())
		}
		
		#[derive(Debug, Clone, Bpaf)]
		pub struct Username {
		    pub user: String
		}
		
		#[derive(Debug, Clone, Bpaf)]
		pub struct Config {
		   #[bpaf(external)]
		   pub verbosity: usize,      // implicit name - "verbosity"
		
		   #[bpaf(external(username))]
		   pub custom_user: Username, // explicit name - "username"
		}
		```
		
		
	 - `postprocessing` - what it says, various methods from [`Parser`][__link53] trait, order matters, most of them are taken literal, see documentation for the trait for more details. usually bpaf can derive what to use here depending on a type: `Option<T>`, `Vec<T>` are supported as is, everything else is assumed to be [`FromStr`][__link54]. If you put anything in the postprocessing section it will disable this logic and you will need to spell out the whole transformation chain.
		
		
	 - field-less enum variants obey slightly different set of rules, see [`req_flag`][__link55] for more details.
		
		
	
	
 - Add documentation for help messages. Help messages are generated from doc comments, bpaf skips single empty lines and stops processing after double empty line:
	
	
	```rust
	use bpaf::*;
	#[derive(Debug, Clone, Bpaf)]
	pub struct Username {
	    /// this is a part of a help message
	    ///
	    /// so is this
	    ///
	    ///
	    /// but this is not
	    pub user: String
	}
	```
	
	


## More examples

A bunch more examples can be found here: <https://github.com/pacak/bpaf/tree/master/examples>

They are usually documented and you can see how they work by cloning the repo and running


```shell
$ cargo run --example example_name
```


## Testing your own parsers

You can test your own parsers to maintain compatibility or simply checking expected output with [`run_inner`][__link57]


```rust

#[derive(Debug, Clone, Bpaf)]
#[bpaf(options)]
pub struct Options {
    pub user: String
}

let help = options()
    .run_inner(Args::from(&["--help"]))
    .unwrap_err()
    .unwrap_stdout();

// assert_eq!(help, ...)
```


 [__cargo_doc2readme_dependencies_info]: ggGkYW0AYXSEG52uRQSwBdezG6GWW8ODAbr5G6KRmT_WpUB5G9hPmBcUiIp6YXKEG-a8_ogEVJmrG3zAmKK3adQoG2q_YfmxBV6BG3uSmqShWaeiYWSBgmRicGFmZjAuNC4xMQ
 [__link0]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::construct
 [__link1]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::Named
 [__link10]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::Named
 [__link11]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::Named::env
 [__link12]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::Named::argument
 [__link13]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::Named::flag
 [__link14]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::Named::switch
 [__link15]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser
 [__link16]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser
 [__link17]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser::map
 [__link18]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser::parse
 [__link19]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser::guard
 [__link2]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::positional
 [__link20]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser::from_str
 [__link21]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser::many
 [__link22]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser::some
 [__link23]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser::optional
 [__link24]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser::fallback
 [__link25]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser::fallback_with
 [__link26]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::construct
 [__link27]: https://docs.rs/bpaf/0.4.11/bpaf/?search=info::Info
 [__link28]: https://docs.rs/bpaf/0.4.11/bpaf/?search=info::Info::for_parser
 [__link29]: https://docs.rs/bpaf/0.4.11/bpaf/?search=info::OptionParser::run
 [__link3]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::command
 [__link30]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser
 [__link31]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::command
 [__link32]: https://docs.rs/bpaf/0.4.11/bpaf/?search=info::OptionParser
 [__link33]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::cargo_helper
 [__link34]: https://docs.rs/bpaf/0.4.11/bpaf/?search=info::Info::version
 [__link35]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::short
 [__link36]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::long
 [__link37]: env()
 [__link38]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::Named::argument
 [__link39]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::positional
 [__link4]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser
 [__link40]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::Named::flag
 [__link41]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::Named::switch
 [__link42]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser::optional
 [__link43]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser::many
 [__link44]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::Named::switch
 [__link45]: https://doc.rust-lang.org/stable/std/?search=std::ffi::OsString
 [__link46]: https://doc.rust-lang.org/stable/std/?search=std::path::PathBuf
 [__link47]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::positional_os
 [__link48]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::Named::argument_os
 [__link49]: https://doc.rust-lang.org/stable/std/?search=std::string::String
 [__link5]: https://docs.rs/bpaf/0.4.11/bpaf/?search=info::OptionParser
 [__link50]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::positional
 [__link51]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::Named::argument
 [__link52]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser
 [__link53]: https://docs.rs/bpaf/0.4.11/bpaf/?search=bpaf::Parser
 [__link54]: https://doc.rust-lang.org/stable/std/?search=std::str::FromStr
 [__link55]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::Named::req_flag
 [__link57]: https://docs.rs/bpaf/0.4.11/bpaf/?search=info::OptionParser::run_inner
 [__link6]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::short
 [__link7]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::long
 [__link8]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::command
 [__link9]: https://docs.rs/bpaf/0.4.11/bpaf/?search=params::positional
