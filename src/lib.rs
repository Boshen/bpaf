#![warn(missing_docs)]
#![warn(rustdoc::missing_doc_code_examples)]
#![allow(clippy::needless_doctest_main)]

//! Lightweight and flexible command line argument parser with derive and combinator style API

//! # Quick start, derive edition
//!
//! 1. Add `bpaf` under `[dependencies]` in your `Cargo.toml`
//! ```toml
//! [dependencies]
//! bpaf = { version = "0.5", features = ["derive"] }
//! ```
//!
//! 2. Define a structure containing command line attributes
//! ```no_run
//! use bpaf::{Bpaf, OptionParser};
//!
//! #[derive(Clone, Debug, Bpaf)]
//! #[bpaf(options, version)]
//! /// Accept speed and distance, print them
//! struct SpeedAndDistance {
//!     /// Speed in KPH
//!     speed: f64,
//!     /// Distance in miles
//!     distance: f64,
//! }
//!
//! fn main() {
//!     // function options is generated by #[derive(Bpaf)] macro
//!     let opts = speed_and_distance().run();
//!     println!("Options: {:?}", opts);
//! }
//! ```
//!
//! 3. Try to run it
//! ```console
//! % very_basic --help
//! Accept speed and distance, print them
//!
//! Usage: --speed ARG --distance ARG
//!
//! Available options:
//!         --speed <ARG>     Speed in KPH
//!         --distance <ARG>  Distance in miles
//!     -h, --help            Prints help information
//!     -V, --version         Prints version information
//!
//! % very_basic --speed 100
//! Expected --distance ARG, pass --help for usage information
//!
//! % very_basic --speed 100 --distance 500
//! Options: SpeedAndDistance { speed: 100.0, distance: 500.0 }
//!
//! % very_basic --version
//! Version: 0.4.11 (taken from Cargo.toml by default)
//!```

//! # Quick start, combinatoric edition
//!
//! 1. Add `bpaf` under `[dependencies]` in your `Cargo.toml`
//! ```toml
//! [dependencies]
//! bpaf = "0.5"
//! ```
//!
//! 2. Declare parsers for components, combine them and run
//! ```no_run
//! use bpaf::{construct, long, Info, OptionParser, Parser};
//! #[derive(Clone, Debug)]
//! struct SpeedAndDistance {
//!     /// Dpeed in KPH
//!     speed: f64,
//!     /// Distance in miles
//!     distance: f64,
//! }
//!
//! fn main() {
//!     let speed = long("speed")
//!         .help("Speed in KPG")
//!         .argument("SPEED")
//!         .from_str::<f64>();
//!
//!     let distance = long("distance")
//!         .help("Distance in miles")
//!         .argument("DIST")
//!         .from_str::<f64>();
//!
//!     let parser = construct!(SpeedAndDistance { speed, distance });
//!     let speed_and_distance
//!         = Info::default()
//!         .descr("Accept speed and distance, print them")
//!         .for_parser(parser);
//!
//!     let opts = speed_and_distance.run();
//!     println!("Options: {:?}", opts);
//! }
//! ```
//!
//! 3. Try to run it, output should be similar to derive edition

//! # Design goals: flexibility, reusability
//!
//! Library allows to express command line arguments by combining primitive parsers using mostly
//! regular Rust code plus one macro. For example it is possible to take a parser that requires a single
//! floating point number and transform it to a parser that takes several of them or takes it
//! optionally so different subcommands or binaries can share a lot of the code:
//!
//! ```no_run
//! use bpaf::*;
//!
//! // a regular function that doesn't depend on anything, can be exported and
//! // shared across subcommands and binaries
//! fn speed() -> impl Parser<f64> {
//!     long("speed")
//!         .help("Speed in KPH")
//!         .argument("SPEED")
//!         .from_str::<f64>()
//! }
//!
//! // this parser accepts multiple `--speed` flags from a command line when used,
//! // collecting them into a vector
//! let multiple_args = speed().many(); // impl Parser<Vec<f64>>
//!
//! // this parser checks if `--speed` is present and uses value of 42 if it is not
//! let with_fallback = speed().fallback(42.0); // impl Parser<Option<f64>>
//! ```
//!
//! At any point you can apply additional validation or fallback values in terms of current parsed
//! state of each subparser and you can have several stages as well:
//!
//! ```no_run
//! use bpaf::*;
//!
//! #[derive(Clone, Debug)]
//! struct Speed(f64);
//!
//! long("speed")
//!     .help("Speed in KPH")
//!     .argument("SPEED")
//!     // After this point we have a parser of type `impl Parser<String>`
//!     .from_str::<f64>()
//!     // `from_str` uses FromStr trait to transform contained value into `f64`
//!
//!     // extra validation can be performed with `parse` or `guard` functions,
//!     // you can have as many steps as required. Before and after those steps
//!     // we still have parser of type `impl Parser<f64>`
//!     .guard(|&speed| speed >= 0.0, "You need to buy a DLC to move backwards")
//!     .guard(|&speed| speed <= 100.0, "You need to buy a DLC to break the speed limits")
//!
//!     // contained values can be transformed, this gives `impl Parser<Speed>` as a result
//!     .map(|speed| Speed(speed));
//! ```

//! # Design goals: restrictions
//!
//! The main restriction library sets is that parsed values (but not the fact that parser succeeded
//! or failed) can't be used to decide how to parse subsequent values. In other words parsers don't
//! have the monadic strength, only the applicative one.
//!
//! To give an example, following description is allowed:
//!
//! > Program takes one of `--stdout` or `--file` flag to specify the output target, when it is `--file`
//! > program also requires `-f` attribute with the file name
//!
//! But this one is not allowed:
//!
//! > Program takes an `-o` attribute with possible values of `'stdout'` and `'file'`, when it's `'file'`
//! > program also requires `-f` attribute with the file name
//!
//! This set of restrictions allows to extract information about the structure of the computations
//! to generate help and overall results in less confusing enduser experience

//! # Derive and combinatoric API
//!
//! Library supports both derive and combinatoric APIs whith combinatoric API being primary, it is
//! possible to mix and match both APIs at once. Combinatoric API provides 100% of the
//! functionality, derive API provides access to about 95% of it. In most cases using just one
//! would suffice. Whenever possible APIs share the same keywords and structure. Documentation for
//! combinatoric API also explains how to perform the same action in derive style so you should
//! read it.

//! # Using the library in combinatoric style
//!
//! 1. Define primitive field parsers using builder pattern starting with [`short`], [`long`],
//! [`command`] or [`positional`], add more information using [`help`](Named), [`env`](Named::env) and
//! other member functions.
//!
//!    For some constructors you end up with parser objects right away,
//!    some require finalization with [`argument`](Named::argument), [`flag`](Named::flag)
//!    or [`switch`](Named::switch).
//!
//!    At the end of this step you'll get one or more parser
//!    one or more objects implementing trait [`Parser`], such as `impl Parser<String>`.
//!
//! 2. If you need additional parsing and validation you can use trait [`Parser`]: [`map`](Parser::map),
//!    [`parse`](Parser::parse), [`guard`](Parser::guard), [`from_str`](Parser::from_str).
//!
//!    You can change type or shape of contained or shape with [`many`](Parser::many),
//!    [`some`](Parser::some), [`optional`](Parser::optional) and add a fallback values with
//!    [`fallback`](Parser::fallback), [`fallback_with`](Parser::fallback_with).
//!
//! 3. You can compose resulting primitive parsers using [`construct`] macro into a concrete
//!    datatype and still apply additional processing from step 2 after this.
//!
//! 4. You define whole program metadata with [`Info`] and apply it to the toplevel parser created
//!    at the previous step using [`for_parser`](Info::for_parser).
//!
//! 5. [`run`](OptionParser::run) the resulting parser at the beginning of your program.
//!    If parser succeeds you'll get the results. If there are errors or user asked for help info
//!    `bpaf` will handle them and exit.

//! # Using the library in derive style
//!
//! 1. To use derive style API you need to enable `"derive"` feature for bpaf, **by default it's not
//!    enabled**.
//!
//! 2. Define primitive parsers if you want to use any. While it is possible to define most of them
//!    in derive style - doing complex parsing or validation is often easier in combinatoric style
//!
//! 3. Define types used to derive parsers, structs correspond to *AND* combination - all the
//!    values will be required, enums to *OR* combinations - only one branch will be accepted.
//!
//! 4. Add annotations to the top level of a struct if needed, there's several to choose from and
//!    you can specify several of them. For this annotation ordering does not matter.
//!
//!    - Generated function name. Unlike usual derive macro bpaf generates a function with a name
//!      derived from a struct name by transforming it from `CamelCase` to `snake_case`. `generate`
//!      allows to override a name for the function
//!
//!    ```rust
//!    use bpaf::*;
//!
//!    #[derive(Debug, Clone, Bpaf)]
//!    #[bpaf(generate(make_config))] // function name is now make_config()
//!    pub struct Config {
//!        pub flag: bool
//!    }
//!    ```
//!
//!    - Generated function visibility. By default bpaf uses the same visibility as the datatype,
//!      `private` makes it module private:
//!
//!    ```rust
//!    use bpaf::*;
//!
//!    #[derive(Debug, Clone, Bpaf)]
//!    #[bpaf(private)] // config() is now private
//!    pub struct Config {
//!        pub flag: bool
//!    }
//!    ```
//!
//!    - Generated function type. By default bpaf would generate a function that parses
//!      all the fields present (`impl` [`Parser`]), it is possible instead to turn it into a
//!      one or more [`command`] with or top level `impl` [`OptionParser`] with `options`.
//!      Those annotations are mutually exclusive. `options` annotation takes an optional argument
//!      to wrap options into [`cargo_helper`], `command` annotation takes an optional argument to
//!      override a command name.
//!
//!    ```rust
//!    use bpaf::*;
//!
//!    #[derive(Debug, Clone, Bpaf)]
//!    pub struct Flag { // impl Parser by default
//!        pub flag: bool
//!    }
//!
//!    #[derive(Debug, Clone, Bpaf)]
//!    #[bpaf(command)]
//!    pub struct Make { // generates a command "make"
//!        pub level: u32,
//!    }
//!
//!
//!    #[derive(Debug, Clone, Bpaf)]
//!    #[bpaf(options)] // config() is now private
//!    pub struct Config {
//!        pub flag: bool
//!    }
//!    ```
//!
//!    - Specify version for generated command. By default bpaf would use version as defined by
//!      `"CARGO_PKG_VERSION"` env variable during compilation, usually taken from `Cargo.toml`,
//!      it is possible to override it with a custom expression. Only makes sense for `command`
//!      and `options` annotations. For more information see [`version`](Info::version).
//!
//!    ```rust
//!    use bpaf::*;
//!
//!    #[derive(Debug, Clone, Bpaf)]
//!    #[bpaf(options, version("3.1415"))] // --version is now 3.1415
//!    pub struct Config {
//!        pub flag: bool
//!    }
//!    ```
//!
//! 5. Add annotations to individual fields. Structure for annotation for individual fields
//!    is similar to how you would write the same code with combinatoric API with exception
//!    of `external` and usually looks something like this:
//!
//!    `((<naming> <consumer>) | <external>) <postprocessing>`
//!
//!    - `naming` section corresponds to [`short`],  [`long`] and [`env`](env()). `short` takes an optional
//!      character literal as a parameter, `long` takes an optional string.
//!
//!      + If parameter for `short`/`long` is parameter is not present it is derived from the field
//!      name: first character and a whole name respectively.
//!
//!      + If either of `short` or `long` is present - bpaf would not add the other one.
//!
//!      + If neither is present - bpaf would add a long one.
//!
//!      + `env` takes an arbitrary expression of type `&'static str` - could be a string literal or a constant.
//!
//!      ```rust
//!      # use bpaf::*;
//!      const DB: &str = "top_secret_database";
//!
//!      #[derive(Debug, Clone, Bpaf)]
//!      pub struct Config {
//!         pub flag_1: bool,     // no annotation: --flag_1
//!
//!         #[bpaf(short)]
//!         pub flag_2: bool,     // explicit short suppresses long: -f
//!
//!         #[bpaf(short('z'))]
//!         pub flag_3: bool,     // explicit short with custom letter: -z
//!
//!         #[bpaf(short, long)]
//!         pub deposit: bool,    // explicit short and long: -d --deposit
//!
//!         #[bpaf(env(DB))]
//!         pub database: String, // --database + env variable from DB constant
//!
//!         #[bpaf(env("USER"))]  // --user + env variable "USER"
//!         pub user: String,
//!      }
//!      ```
//!
//!    - `consumer` section corresponds to [`argument`](Named::argument), [`positional`],
//!      [`flag`](Named::flag), [`switch`](Named::switch) and similar.
//!
//!      + With no consumer annotations tuple structs (`struct Config(String)`) are usually parsed
//!      as positional items, but it is possible to override it by giving it a name:
//!
//!      ```rust
//!      # use bpaf::*;
//!      # use std::path::PathBuf;
//!
//!      #[derive(Debug, Clone, Bpaf)]
//!      struct Opt(PathBuf); // stays positional
//!
//!      #[derive(Debug, Clone, Bpaf)]
//!      struct Config(#[bpaf(long("input"))] PathBuf); // turns into a named argument
//!      ```
//!
//!      + Fields of type `Option<Foo>` and `Vec<Foo>` are turned into something that consumes
//!      possibly one or many items with [`optional`](Parser::optional) and [`many`](Parser::many)
//!      respectively, see `postprocessing` for more details.
//!
//!      + `bool` fields are turned into [`switch`](Named::switch),
//!      [`OsString`](std::ffi::OsString) and [`PathBuf`](std::path::PathBuf) are consumed
//!      as either [`positional_os`] or [`argument_os`](Named::argument_os). Everything
//!      else is consumed as [`String`] with [`positional`] and [`argument`](Named::argument).
//!      See documentation for corresponding consumers for more details.
//!
//!    - `external` section usually replaces `naming`, `consumer` and optionally `postprocessing`
//!      sections. Takes an optional parameter - a function name to call, if not present - it will
//!      use field name for this purpose. Functions should return impl [`Parser`] and you can
//!      either declare them manually or derive with `Bpaf` macro.
//!
//!      ```rust
//!      use bpaf::*;
//!
//!      fn verbosity() -> impl Parser<usize> {
//!          short('v')
//!              .help("vebosity, can specify multiple times")
//!              .req_flag(())
//!              .many()
//!              .map(|x| x.len())
//!      }
//!
//!      #[derive(Debug, Clone, Bpaf)]
//!      pub struct Username {
//!          pub user: String
//!      }
//!
//!      #[derive(Debug, Clone, Bpaf)]
//!      pub struct Config {
//!         #[bpaf(external)]
//!         pub verbosity: usize,      // implicit name - "verbosity"
//!
//!         #[bpaf(external(username))]
//!         pub custom_user: Username, // explicit name - "username"
//!      }
//!      ```
//!
//!    - `postprocessing` - what it says, various methods from [`Parser`] trait, order matters,
//!    most of them are taken literal, see documentation for the trait for more details. usually
//!    bpaf can derive what to use here depending on a type: `Option<T>`, `Vec<T>` are supported as
//!    is, everything else is assumed to be [`FromStr`](std::str::FromStr). If you put anything
//!    in the postprocessing section it will disable this logic and you will need to spell out
//!    the whole transformation chain.
//!
//!
//! 6. Add documentation for help messages.
//!    Help messages are generated from doc comments, bpaf skips single empty lines and stops
//!    processing after double empty line:
//!
//!    ```rust
//!    use bpaf::*;
//!    #[derive(Debug, Clone, Bpaf)]
//!    pub struct Username {
//!        /// this is a part of a help message
//!        ///
//!        /// so is this
//!        ///
//!        ///
//!        /// but this is not
//!        pub user: String
//!    }
//!    ```

//! # More examples
//!
//! A bunch more examples can be found here: <https://github.com/pacak/bpaf/tree/master/examples>
//!
//! They are usually documented and you can see how they work by cloning the repo and running
//!
//! ```shell
//! $ cargo run --example example_name
//! ```

//! # Testing your own parsers
//!
//! You can test your own parsers to maintain compatibility or simply checking expected output
//! with [`run_inner`](OptionParser::run_inner)
//!
//! ```rust
//! # use bpaf::*;
//!
//! #[derive(Debug, Clone, Bpaf)]
//! #[bpaf(options)]
//! pub struct Options {
//!     pub user: String
//! }
//!
//! let help = options()
//!     .run_inner(Args::from(&["--help"]))
//!     .unwrap_err()
//!     .unwrap_stdout();
//!
//! // assert_eq!(help, ...)
//! # drop(help);
//! ```

use std::marker::PhantomData;

mod params;

mod args;

#[doc(hidden)]
pub mod info;
#[doc(hidden)]
pub mod item;
#[doc(hidden)]
pub mod meta;

pub mod structs;
use crate::{info::Error, item::Item};
pub use structs::ParseConstruct;
use structs::{
    ParseDefault, ParseFail, ParseFallback, ParseFallbackWith, ParseFromStr, ParseGroupHelp,
    ParseGuard, ParseHide, ParseMany, ParseMap, ParseOptional, ParseOrElse, ParsePure, ParseSome,
    ParseWith,
};

#[cfg(test)]
mod tests;
#[doc(inline)]
pub use crate::args::Args;
pub use crate::info::{Info, OptionParser};
pub use crate::meta::Meta;

#[doc(inline)]
pub use crate::params::{
    command, env, long, positional, positional_if, positional_os, short, Command, Named,
};

#[doc(inline)]
#[cfg(feature = "bpaf_derive")]
pub use bpaf_derive::Bpaf;

/// Compose several parsers to produce a single result
///
/// Every parser must succeed in order to produce a result for
/// sequential composition and only one parser needs to succeed
/// for a parallel one (`construct!([a, b, c])`)
///
/// Each parser must be present in a local scope and
/// have the same name as struct field. Alternatively
/// a parser can be present as a function producing a parser
/// bpaf will call this function and use it's result. Later
/// option might be useful when single parser is used in
/// several `construct!` macros
///
/// ```rust
/// # use bpaf::*;
/// struct Res {
///     a: bool,
///     b: u32,
/// }
///
/// // parser defined as a local variable
/// let a = short('a').switch();
///
/// // parser defined as a function
/// fn b() -> impl Parser<u32> {
///     short('b').argument("B").from_str()
/// }
///
/// // resulting parser returns Res and requires both a and b to succeed
/// let res = construct!(Res { a, b() });
/// # drop(res);
/// ```
///
/// `construct!` supports following representations:
///
/// - structs with unnamed fields:
/// ```rust ignore
/// construct!(Res(a, b))
/// ```
/// - structs with named fields:
/// ```ignore
/// construct!(Res {a, b})
/// ```
/// - enums with unnamed fields:
/// ```ignore
/// construct!(Ty::Res(a, b))
/// ```
/// - enums with named fields:
/// ```ignore
/// construct!(Ty::Res {a, b})
/// ```
/// - tuples:
/// ```ignore
/// construct!(a, b)
/// ```
/// - parallel composition, a equivalent of `a.or_else(b).or_else(c)`
/// ```ignore
/// construct!([a, b, c])
/// ```
#[macro_export]
macro_rules! construct {
    // construct!(Enum::Cons { a, b, c })
    ($ns:ident $(:: $con:ident)* { $($tokens:tt)* }) => {{ $crate::construct!(@prepare [named [$ns $(:: $con)*]] [] $($tokens)*) }};
    (:: $ns:ident $(:: $con:ident)* { $($tokens:tt)* }) => {{ $crate::construct!(@prepare [named [:: $ns $(:: $con)*]] [] $($tokens)*) }};
    // construct!(Enum::Cons ( a, b, c ))
    ($ns:ident $(:: $con:ident)* ( $($tokens:tt)* )) => {{ $crate::construct!(@prepare [pos [$ns $(:: $con)*]] [] $($tokens)*) }};
    (:: $ns:ident $(:: $con:ident)* ( $($tokens:tt)* )) => {{ $crate::construct!(@prepare [pos [:: $ns $(:: $con)*]] [] $($tokens)*) }};

    // construct!( a, b, c )
    ($first:ident , $($tokens:tt)*) => {{ $crate::construct!(@prepare [pos] [] $first , $($tokens)*) }};
    ($first:ident (), $($tokens:tt)*) => {{ $crate::construct!(@prepare [pos] [] $first (), $($tokens)*) }};

    // construct![a, b, c]
    ([$first:ident $($tokens:tt)*]) => {{ $crate::construct!(@prepare [alt] [] $first $($tokens)*) }};

    (@prepare $ty:tt [$($fields:tt)*] $field:ident (), $($rest:tt)*) => {{
        let $field = $field();
        $crate::construct!(@prepare $ty [$($fields)* $field] $($rest)*)
    }};
    (@prepare $ty:tt [$($fields:tt)*] $field:ident () $($rest:tt)*) => {{
        let $field = $field();
        $crate::construct!(@prepare $ty [$($fields)* $field] $($rest)*)
    }};
    (@prepare $ty:tt [$($fields:tt)*] $field:ident, $($rest:tt)*) => {{
        $crate::construct!(@prepare $ty [$($fields)* $field] $($rest)*)
    }};
    (@prepare $ty:tt [$($fields:tt)*] $field:ident $($rest:tt)*) => {{
        $crate::construct!(@prepare $ty [$($fields)* $field] $($rest)*)
    }};

    (@prepare [alt] [$first:ident $($fields:ident)*]) => {{
        use $crate::Parser; $first $(.or_else($fields))*
    }};

    (@prepare $ty:tt [$($fields:tt)*]) => {{
        use $crate::Parser;
        let meta = $crate::Meta::And(vec![ $($fields.meta()),* ]);
        let inner = move |args: &mut $crate::Args| {
            $(let $fields = $fields.run(args)?;)*
            ::std::result::Result::Ok::<_, $crate::info::Error>
                ($crate::construct!(@make $ty [$($fields)*]))
        };
        $crate::ParseConstruct { inner, meta }
    }};

    (@make [named [$($con:tt)+]] [$($fields:ident)*]) => { $($con)+ { $($fields),* } };
    (@make [pos   [$($con:tt)+]] [$($fields:ident)*]) => { $($con)+ ( $($fields),* ) };
    (@make [pos] [$($fields:ident)*]) => { ( $($fields),* ) };
}

/// Simple or composed argument parser
pub trait Parser<T> {
    /// Evaluate inner function
    ///
    /// Mostly internal implementation details, you can try using it to test your parsers
    // it is possible to move this function from the trait to the structs but having it
    // in the trait ensures the composition
    #[doc(hidden)]
    fn run(&self, args: &mut Args) -> Result<T, Error>;

    /// Included information about the parser
    ///
    /// Mostly internal implementation details, you can try using it to test your parsers
    // it is possible to move this function from the trait to the structs but having it
    // in the trait ensures the composition
    #[doc(hidden)]
    fn meta(&self) -> Meta;

    /// Consume zero or more items from a command line and collect them into [`Vec`]
    ///
    /// # Combinatoric usage:
    /// ```rust
    /// # use bpaf::*;
    /// let numbers
    ///     = short('n')
    ///     .argument("NUM")
    ///     .from_str::<u32>()
    ///     .many();
    /// # drop(numbers);
    /// ```
    ///
    /// # Derive usage:
    /// Bpaf would insert implicit `many` when resulting type is a vector
    /// ```rust
    /// # use bpaf::*;
    /// #[derive(Debug, Clone, Bpaf)]
    /// struct Options {
    ///     #[bpaf(short, argument("NUM"))]
    ///     numbers: Vec<u32>
    /// }
    /// ```
    /// But it is also possible to specify it explicitly, both cases renerate the same code.
    /// Note, since using `many` resets the postprocessing chain - you also need to specify
    /// [`from_str`](Parser::from_str)
    /// ```rust
    /// # use bpaf::*;
    /// #[derive(Debug, Clone, Bpaf)]
    /// struct Options {
    ///     #[bpaf(short, argument("NUM"), from_str(u32), many)]
    ///     numbers: Vec<u32>
    /// }
    /// ```
    ///
    ///
    /// # Example
    /// ```console
    /// $ app -n 1 -n 2 -n 3
    /// // [1, 2, 3]
    /// ```
    ///
    /// # Panics
    /// Panics if parser succeeds without consuming any input: any parser modified with
    /// `many` must consume something,
    ///
    /// # See also
    /// [`some`](Parser::some) also collects results to a vector but requires at least one
    /// element to succeed
    fn many(self) -> ParseMany<Self>
    where
        Self: Sized,
    {
        ParseMany { inner: self }
    }

    /// Parse stored [`String`] using [`FromStr`](std::str::FromStr) instance
    ///
    /// # Combinatoric usage
    /// ```rust
    /// # use bpaf::*;
    /// fn speed() -> impl Parser<f64> {
    ///     short('s')
    ///         .argument("SPEED")
    ///         .from_str::<f64>()
    /// }
    /// ```
    ///
    /// # Derive usage
    ///
    /// By default bpaf_derive would use from_str for any time it is not
    /// familiar with so you don't need to specify anything
    /// ```rust
    /// # use bpaf::*;
    /// #[derive(Debug, Clone, Bpaf)]
    /// struct Options {
    ///     #[bpaf(short, argument("SPEED"))]
    ///     speed: f64
    /// }
    /// ```
    ///
    /// But it is also possible to specify it explicitly
    /// ```rust
    /// # use bpaf::*;
    /// #[derive(Debug, Clone, Bpaf)]
    /// struct Options {
    ///     #[bpaf(short, argument("SPEED"), from_str(f64))]
    ///     speed: f64
    /// }
    /// ```
    ///
    /// # Example
    /// ```console
    /// $ app -s pi
    /// // fails with "Couldn't parse "pi": invalid float literal"
    /// $ app -s 3.1415
    /// // 3.1415
    /// ```
    ///
    /// # See also
    /// Other parsing and restricting methods include [`parse`](Parser::parse) and
    /// [`guard`](Parser). For transformations that can't fail you can use [`map`](Parser::map).
    #[must_use]
    #[allow(clippy::wrong_self_convention)]
    fn from_str<R>(self) -> ParseFromStr<Self, R>
    where
        Self: Sized + Parser<T>,
    {
        ParseFromStr {
            inner: self,
            ty: PhantomData,
        }
    }

    /// Turn a required parser into optional
    ///
    /// # Combinatoric usage
    /// ```rust
    /// # use bpaf::*;
    /// let number = short('n')
    ///     .argument("NUM")
    ///     .from_str::<u32>()
    ///     .optional();
    /// # drop(number);
    /// ```
    ///
    /// # Derive usage
    ///
    /// By default bpaf would automatically use optional for fields of type `Option<T>`,
    /// for as long as it's not prevented from doing so by present postprocessing options
    /// ```rust
    /// # use bpaf::*;
    /// #[derive(Debug, Clone, Bpaf)]
    /// struct Options {
    ///    #[bpaf(short, argument("NUM"))]
    ///    number: Option<u32>
    /// }
    /// ```
    ///
    /// But it is also possible to specify it explicitly, in which case you need to specify
    /// a full postprocessing chain which starts from [`from_str`](Parser::from_str) in this
    /// example.
    /// ```rust
    /// # use bpaf::*;
    /// #[derive(Debug, Clone, Bpaf)]
    /// struct Options {
    ///    #[bpaf(short, argument("NUM"), from_str(u32), optional)]
    ///    number: Option<u32>
    /// }
    /// ```
    ///
    /// # Example
    /// ```console
    /// $ app
    /// // None
    /// $ app -n 42
    /// // Some(42)
    /// ```
    #[must_use]
    fn optional(self) -> ParseOptional<Self>
    where
        Self: Sized + Parser<T>,
    {
        ParseOptional { inner: self }
    }

    /// Validate or fail with a message
    ///
    /// Parser will reject values that fail to satisfy the constraints
    ///
    /// # Combinatoric usage
    ///
    /// ```rust
    /// # use bpaf::*;
    /// let number = short('n')
    ///     .argument("NUM")
    ///     .from_str::<u32>()
    ///     .guard(|n| *n <= 10, "Values greater than 10 are only available in the DLC pack!");
    /// # drop(number);
    /// ```
    ///
    /// # Derive usage
    /// Unlike combinator counterpart, derive variant of `guard` takes a function name instead
    /// of a closure, mostly to keep thing clean. Second argument can be either a string literal
    /// or a constant name for a static [`str`].
    ///
    /// ```rust
    /// # use bpaf::*;
    /// fn dlc_check(number: &u32) -> bool {
    ///     *number <= 10
    /// }
    ///
    /// const DLC_NEEDED: &str = "Values greater than 10 are only available in the DLC pack!";
    ///
    /// #[derive(Debug, Clone, Bpaf)]
    /// struct Options {
    ///     #[bpaf(short, argument("NUM"), guard(dlc_check, DLC_NEEDED))]
    ///     number: u32,
    /// }
    /// ```
    ///
    /// # Example
    /// ```console
    /// $ app -n 100
    /// // fails with "Values greater than 10 are only available in the DLC pack!"
    /// $ app -n 5
    /// // 5
    /// ```
    #[must_use]
    fn guard<F>(self, check: F, message: &'static str) -> ParseGuard<Self, F>
    where
        Self: Sized + Parser<T>,
        F: Fn(&T) -> bool,
    {
        ParseGuard {
            inner: self,
            check,
            message,
        }
    }

    /// Use this value as default if value is not present on a command line
    ///
    /// Would still fail if value is present but failure comes from some transformation
    /// ```rust
    /// # use bpaf::*;
    /// let n = short('n').argument("NUM").from_str::<u32>().fallback(42);
    /// # drop(n)
    /// ```
    #[must_use]
    fn fallback(self, value: T) -> ParseFallback<Self, T>
    where
        Self: Sized + Parser<T>,
    {
        ParseFallback { inner: self, value }
    }

    /// Use value produced by this function as default if value is not present
    ///
    /// Would still fail if value is present but failure comes from some transformation
    /// ```rust
    /// # use bpaf::*;
    /// let n = short('n').argument("NUM").from_str::<u32>();
    /// let n = n.fallback_with(|| Result::<u32, String>::Ok(42));
    /// # drop(n)
    /// ```
    #[must_use]
    fn fallback_with<F, E>(self, fallback: F) -> ParseFallbackWith<T, Self, F, E>
    where
        Self: Sized + Parser<T>,
        F: Fn() -> Result<T, E>,
        E: ToString,
    {
        ParseFallbackWith {
            inner: self,
            inner_res: PhantomData,
            fallback,
            err: PhantomData,
        }
    }

    /// Parse `T` or fallback to `T::default()`
    ///
    /// ```rust
    /// # use bpaf::*;
    /// let n = short('n').argument("NUM").from_str::<u32>().or_default();
    /// # drop(n)
    /// ```
    #[must_use]
    fn or_default(self) -> ParseDefault<T, Self>
    where
        Self: Sized + Parser<T>,
        T: Default + 'static + Clone,
    {
        ParseDefault {
            inner: self,
            inner_res: PhantomData,
        }
    }

    /// Apply a failing transformation
    ///
    /// See also [`from_str`][Parser::from_str]
    /// ```rust
    /// # use bpaf::*;
    /// let s = short('n').argument("NUM");
    /// // Try to parse String into u32 or fail during the parsing
    /// use std::str::FromStr;
    /// let n = s.map(|s| u32::from_str(&s));
    /// // n: impl Parser<u32>
    /// # drop(n);
    /// ```
    fn parse<F, E, R>(self, f: F) -> ParseWith<T, Self, F, E, R>
    where
        Self: Sized + Parser<T>,
        F: Fn(T) -> Result<R, E>,
        E: ToString,
    {
        ParseWith {
            inner: self,
            inner_res: PhantomData,
            parse_fn: f,
            res: PhantomData,
            err: PhantomData,
        }
    }

    /// If first parser fails - try the second one
    ///
    /// ```rust
    /// # use bpaf::*;
    /// let a = short('a').switch();
    /// let b = short('b').switch();
    ///
    /// // Parser will accept either `-a` or `-b` on a command line but not both at once.
    /// let a_or_b = a.or_else(b); // impl Parser<bool>
    /// # drop(a_or_b);
    /// ```
    ///
    /// # Performance
    ///
    /// If first parser succeeds - second one will be called anyway to produce a
    /// better error message for combinations of mutually exclusive parsers:
    ///
    /// Suppose program accepts one of two mutually exclusive switches `-a` and `-b`
    /// and both are present error message should point at the second flag
    ///
    /// [`construct!`] can be used to perform a similar task and might generate better code if
    /// combines more than two parsers. Those two invocations are equivalent:
    ///
    /// ```ignore
    /// let abc = a.or_else(b).or_else(c);
    /// ```
    /// ```ignore
    /// let abc = construct!([a, b, c]);
    /// ```
    ///
    fn or_else<P>(self, alt: P) -> ParseOrElse<Self, P>
    where
        Self: Sized + Parser<T>,
        P: Sized + Parser<T>,
    {
        ParseOrElse {
            this: self,
            that: alt,
        }
    }

    /// Apply a pure transformation to a contained value
    ///
    /// ```rust
    /// # use bpaf::*;
    /// let n = short('n').argument("NUM").from_str::<u32>(); // impl Parser<u32>
    /// // produced value is now twice as large
    /// let n = n.map(|v| v * 2);
    /// # drop(n);
    /// ```
    fn map<F, R>(self, map: F) -> ParseMap<T, Self, F, R>
    where
        Self: Sized + Parser<T>,
        F: Fn(T) -> R + 'static,
    {
        ParseMap {
            inner: self,
            inner_res: PhantomData,
            map_fn: map,
            res: PhantomData,
        }
    }

    /// Ignore this parser during any sort of help generation
    ///
    /// Best used for optional parsers or parsers with a defined fallback
    ///
    /// ```rust
    /// # use bpaf::*;
    /// // bpaf will accept `-w` but won't show it during help generation
    /// let width = short('w').argument("PX").from_str::<u32>().fallback(10).hide();
    /// let height = short('h').argument("PX").from_str::<u32>();
    /// let rect = construct!(width, height);
    /// # drop(rect);
    /// ```
    ///
    /// See also `examples/cargo-cmd.rs`
    fn hide(self) -> ParseHide<Self>
    where
        Self: Sized + Parser<T>,
    {
        ParseHide { inner: self }
    }

    /// Consume one or more items from a command line
    ///
    /// Takes a string literal that will be used as an
    /// error message if there's no specified parameters
    ///
    /// # Combinatoric usage:
    /// ```rust
    /// # use bpaf::*;
    /// let numbers
    ///     = short('n')
    ///     .argument("NUM")
    ///     .from_str::<u32>()
    ///     .some("Need at least one number");
    /// # drop(numbers);
    /// ```
    ///
    /// # Derive usage
    /// Since using `some` resets the postprocessing chain - you also need to specify
    /// [`from_str`](Parser::from_str)
    /// ```rust
    /// # use bpaf::*;
    /// #[derive(Debug, Clone, Bpaf)]
    /// struct Options {
    ///     #[bpaf(short, argument("NUM"), from_str(u32), some("Need at least one number"))]
    ///     numbers: Vec<u32>
    /// }
    /// ```
    ///
    ///
    /// # Example
    /// ```console
    /// $ app
    /// // fails with "Need at least one number"
    /// $ app -n 1 -n 2 -n 3
    /// // [1, 2, 3]
    /// ```
    ///
    /// # Panics
    /// Panics if parser succeeds without consuming any input: any parser modified with
    /// `many` must consume something,
    ///
    /// # See also
    /// [`many`](Parser::many) also collects results to a vector and will succeed with
    /// no matching values

    #[must_use]
    fn some(self, message: &'static str) -> ParseSome<Self>
    where
        Self: Sized + Parser<T>,
    {
        ParseSome {
            inner: self,
            message,
        }
    }

    /// Attach help message to a complex parser
    ///
    /// ```rust
    /// # use bpaf::*;
    /// let width = short('w').argument("PX").from_str::<u32>();
    /// let height = short('h').argument("PX").from_str::<u32>();
    /// let rect = construct!(width, height).group_help("take a rectangle");
    /// # drop(rect);
    /// ```
    /// See `examples/rectangle.rs` for a complete example
    fn group_help(self, message: &'static str) -> ParseGroupHelp<Self>
    where
        Self: Sized + Parser<T>,
    {
        ParseGroupHelp {
            inner: self,
            message,
        }
    }
}

/// Wrap a value into a `Parser`
///
/// Parser will produce `T` without consuming anything from the command line, can be useful
/// with [`construct!`].
///
/// ```rust
/// # use bpaf::*;
/// let a = long("flag-a").switch();
/// let b = pure(42u32);
/// let t = construct!(a, b); // impl Parser<(bool, u32)>
/// # drop(t)
/// ```
#[must_use]
pub fn pure<T>(val: T) -> ParsePure<T> {
    ParsePure(val)
}

/// Fail with a fixed error message
/// ```rust
/// # use bpaf::*;
/// let a = short('a').switch();
/// let no_a = fail("Custom error message for missing -a");
///
/// // Parser will produce a custom error message if `-a` is not specified
/// let a_ = construct!([a, no_a]); // impl Parser<bool>
/// # drop(a_);
/// ```
#[must_use]
pub fn fail<T>(msg: &'static str) -> ParseFail<T> {
    ParseFail {
        field1: msg,
        field2: PhantomData,
    }
}

/// Unsuccessful command line parsing outcome
///
/// Useful for unit testing for user parsers, intented to
/// be consumed with [`ParseFailure::unwrap_stdout`] and [`ParseFailure::unwrap_stdout`]
#[derive(Clone, Debug)]
pub enum ParseFailure {
    /// Terminate and print this to stdout
    Stdout(String),
    /// Terminate and print this to stderr
    Stderr(String),
}

impl ParseFailure {
    /// Returns the contained `stderr` values
    ///
    /// Intended to be used with unit tests
    ///
    /// # Panics
    ///
    /// Will panic if failure contains `stdout`
    #[allow(clippy::must_use_candidate)]
    pub fn unwrap_stderr(self) -> String {
        match self {
            Self::Stderr(err) => err,
            Self::Stdout(_) => {
                panic!("not an stderr: {:?}", self)
            }
        }
    }

    /// Returns the contained `stdout` values
    ///
    /// Intended to be used with unit tests
    ///
    /// # Panics
    ///
    /// Will panic if failure contains `stderr`
    #[allow(clippy::must_use_candidate)]
    pub fn unwrap_stdout(self) -> String {
        match self {
            Self::Stdout(err) => err,
            Self::Stderr(_) => {
                panic!("not an stdout: {:?}", self)
            }
        }
    }
}

/// Strip a command name if present at the front when used as a cargo command
///
/// This helper should be used on a top level parser
///
/// ```rust
/// # use bpaf::*;
/// let width = short('w').argument("PX").from_str::<u32>();
/// let height = short('h').argument("PX").from_str::<u32>();
/// let parser = cargo_helper("cmd", construct!(width, height)); // impl Parser<(u32, u32)>
/// # drop(parser);
/// ```
#[must_use]
pub fn cargo_helper<P, T>(cmd: &'static str, parser: P) -> impl Parser<T>
where
    T: 'static,
    P: Parser<T>,
{
    let skip = positional_if("", move |s| cmd == s).hide();
    construct!(skip, parser).map(|x| x.1)
}
