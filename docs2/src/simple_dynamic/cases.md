Let's consider a simple application that performs crate analysis

Application generates help message as usual

> --help

Shell (zsh in this case) with help of completion system can request possible items to type
along with some description

zsh> simple_dynamic \t

When user provides enough input to identify a possible item - shell substitutes it and allows
to perform more completions

zsh> simple_dynamic --j\t

Since all output format keys are mutually exclusive - with `--json` already present on a
command line `--xml` and `--text` won't show up

zsh> simple_dynamic --json \t

With dynamic completion it is easy to provide shell with more details. For example one of the
options your application can take can be a crate name from reverse dependencies. Using
`complete` method you can tell `bpaf` what values your parser expects and `bpaf` would
communicate this to shell. In this example possible completions are generated by `crates`
function from a static list, but you can use any other source. `bpaf` would only call `crates`
function when trying to complete a crate name.

zsh> simple_dynamic --json --crate \t

As usual completion system uses input to filter on possible variants

zsh> simple_dynamic --json --crate cargo-\t

And as soon as there's enough to identify input in a unique way - shell would substitute it.

zsh> simple_dynamic --json --crate cargo-ha\t

Outside of generating completion info - `complete` annotation does not affect the results

> --json --crate cargo-hackerman
